local s = require("luasnip").snippet
local t = require("luasnip").text_node
local i = require("luasnip").insert_node

return {
	s("pyt", {
		t({
			"import sys",
			"from collections import defaultdict, deque, Counter",
			"from bisect import bisect_left, bisect_right",
			"from heapq import heappush, heappop, heapify",
			"from math import gcd, lcm, sqrt, ceil, floor",
			"",
			"input = sys.stdin.readline",
			"",
			"def inp():",
			"    return int(input())",
			"",
			"def inlt():",
			"    return list(map(int, input().split()))",
			"",
			"def insr():",
			"    return list(input().strip())",
			"",
			"def invr():",
			"    return map(int, input().split())",
			"",
			"def ins():",
			"    return input().strip()",
			"",
			"def solve():",
			"    ",
		}),
		i(1, "# Your solution here"),
		t({
			"",
			"    pass",
			"",
			"if __name__ == '__main__':",
			"    t = inp()",
			"    for _ in range(t):",
			"        solve()",
		}),
	}),
	s("dsu", {
		t({
			"class UnionFind:",
			"    def __init__(self, n):",
			"        self.parent = list(range(n))",
			"        self.rank = [0] * n",
			"",
			"    def find(self, x):",
			"        if self.parent[x] != x:",
			"            self.parent[x] = self.find(self.parent[x])",
			"        return self.parent[x]",
			"",
			"    def union(self, x, y):",
			"        root_x = self.find(x)",
			"        root_y = self.find(y)",
			"",
			"        if root_x == root_y:",
			"            return False",
			"",
			"        if self.rank[root_x] < self.rank[root_y]:",
			"            self.parent[root_x] = root_y",
			"        elif self.rank[root_x] > self.rank[root_y]:",
			"            self.parent[root_y] = root_x",
			"        else:",
			"            self.parent[root_y] = root_x",
			"            self.rank[root_x] += 1",
			"        return True",
		}),
	}),
}

